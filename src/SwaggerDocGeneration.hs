{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeOperators #-}

module SwaggerDocGeneration where

import Servant ( QueryParam
               , PlainText
               , Get
               , JSON
               , Proxy(..)
               , MimeRender
               , type (:>)      -- Syntax for importing type operator
               , type (:<|>)
               , (:<|>)(..)
               )
import Servant.Server (Handler, Server, Application, serve)
import Network.Wai.Handler.Warp (run)
import Control.Monad.IO.Class (liftIO)
import GHC.Generics

import Servant.Swagger (toSwagger)
import Data.Swagger (Swagger, ToSchema)

-- This module show how to add an endpoint that serves the api documentation in a json format

handlerPerson :: Handler Person
handlerPerson = return $ Person "Sandeep" 40

handlerAge :: Handler String
handlerAge = return "30"

data Person = Person
  { prName :: String
  , prAge :: Int
  } deriving (Generic, ToSchema)

instance MimeRender PlainText Person where


type ServantType =  "person" :> "name" :> Get '[PlainText] Person
               :<|> "person" :> "age" :> Get '[PlainText] String

server :: Server ServantType
server = handlerPerson :<|> handlerAge
--
-- Everything is same upto this point
-- In the section below, we create an Handler to serve the api documentation.
-- The return type of this handler is 'Swagger'. It is generated by toSwagger
-- function from Servant.Swagger module.
--
handlerDoc :: Handler Swagger
handlerDoc = return $ toSwagger (Proxy :: Proxy ServantType)

-- Below, we create a new Server type by appending the corresponding type of endpoint for
-- the above handler to the original Server type we have defined before.

type ServantTypeWithDoc = ServantType :<|> ("api" :> Get '[JSON] Swagger)

-- Below, we create a new server that also includes the documentation handler so that it matches
-- with the Server type we created just before.

serverWithDoc :: Server ServantTypeWithDoc
serverWithDoc = server :<|> handlerDoc

app :: Application
app = serve (Proxy :: Proxy ServantTypeWithDoc) serverWithDoc

mainFn :: IO ()
mainFn = run 4000 app

-- curl -v   http://127.0.0.1/api
-- *   Trying 127.0.0.1...
-- * Connected to 127.0.0.1 (127.0.0.1) port 80 (#0)
-- > GET /api HTTP/1.1
-- > Host: 127.0.0.1
-- > User-Agent: curl/7.47.0
-- > Accept: */*
-- >
-- < HTTP/1.1 200 OK
-- < Server: nginx/1.10.3 (Ubuntu)
-- < Date: Sun, 22 Jul 2018 16:07:05 GMT
-- < Content-Type: application/json;charset=utf-8
-- < Transfer-Encoding: chunked
-- < Connection: keep-alive
-- <
-- * Connection #0 to host 127.0.0.1 left intact
-- {"swagger":"2.0","info":{"version":"","title":""},"paths":{"/person/name":{"get":{"produces":["text/plain;charset=utf-8"],"responses":{"200":{"schema":{"type":"string"},"description":""}}}},"/person/age":{"get":{"produces":["text/plain;charset=utf-8"],"responses":{"200":{"schema":{"type":"string"},"description":""}}}}}}s
--
--  After prettifying the json is as follows. You can see the two endpoints in there.
-- {
--   "swagger": "2.0",
--   "info": {
--     "version": "",
--     "title": ""
--   },
--   "paths": {
--     "/person/name": {
--       "get": {
--         "produces": [
--           "text/plain;charset=utf-8"
--         ],
--         "responses": {
--           "200": {
--             "schema": {
--               "type": "string"
--             },
--             "description": ""
--           }
--         }
--       }
--     },
--     "/person/age": {
--       "get": {
--         "produces": [
--           "text/plain;charset=utf-8"
--         ],
--         "responses": {
--           "200": {
--             "schema": {
--               "type": "string"
--             },
--             "description": ""
--           }
--         }
--       }
--     }
--   }
-- }
